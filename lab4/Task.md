# Лабораторная работа 4

В данной лабораторной работе вам предстоит на железе реализовать управление 7-сегментым индикатором и 8 диодами на плате расширителе.

## Знакомство со средой разработки Gowin EDA.

Для выполнения работы потребуется изучить схемы отладочной платы **SiPEEd Tang Primer 20k**. Схемы и другая документация выложена на *OneDrive* в папке *docs*.

[Описание](https://wiki.sipeed.com/hardware/en/tang/tang-primer-20k/primer-20k.html) отладочной платы.

[Установка IDE.](https://wiki.sipeed.com/hardware/en/tang/Tang-Nano-Doc/install-the-ide.html)

[Tutorial](https://wiki.sipeed.com/hardware/en/tang/tang-primer-20k/examples/led.html) по созданию проекта и прошивке ПЛИС.

## Основные ограничение

В данной лабораторной работе **запрещается синтез защелок**, а также есть ограничение на использованные LUT. После вашего синтеза в первой части должно быть **ровно 8 LUT**, во второй части не должно быть больше чем **800 LUT**.

Данную информацию можно посмотреть в `Syntesis Report` во вкладке `Process`.

Также в **первой части** у вас **должно быть 0 Warnings**

## Часть 1

Требуется используя реализованный внутри GOWIN примитив LUT3 реализовать простые логические функции и результат вывести на 8 диодов на плате.

**Запрещается использование чего-либо кроме LUT**, все ваши логические функции должны быть реализованы через них. Все логические функции будут с тремя входами.

Все диоды подписаны на плате, их номер и их порт.

Документацию на LUT3 вы можете найти в папке `GOWIN -> IDE -> doc -> EN -> UG303-1.0E_Arora Ⅴ Configurable Function Unit (CFU) User Guide.pdf`

Таблица функций:

| Диод       | Обозначение Функции     | Функция       |
|:---------------|:--------------:|-------------:|
| 1          | $f_1$          | $A \oplus B + C$        |
| 2          | $f_2$          | $A \oplus C$        |
| 3          | $f_3$          | $B + f_1$        |
| 4          | $f_4$          | $f_1 f_2f_3$        |
| 5          | $f_5$          | $A + B + C$        |
| 6          | $f_6$          | $\overline{A \oplus B + C}$|
| 7          | $f_7$          | $ABC$        |
| 8          | $f_8$          | $C$        |

Значения должны задаваться через кнопки на самой ПЛИС, их распиновка на обратной стороне платы.

A - S0

B - S1

C - S2

## Часть 2

В данной части вам можно пользоваться любыми блоками.

Вам необходимо реализовать блок контроллера вывода 8 разрядного числа на 7-сегментный индикатор.

Ваше число должно меняться каждую секунду.

На стенде расположено два 4-разряджных 7-сегментных индикатора (*2481BS-1*). Управление индикаторами осуществляется при помощи 2-х сдвиговых регистров.

Обратите внимание, что в отличие от Лабораторной работы 2, здесь есть бит для точки, то есть один сегмент кодируется 8 битами. Также 8 битами кодируется и положение числа. Число на индикатор передается пакетом 16 бит.

Схему можете найти на облаке курса.

О том, как это работает, можете почитать в этих статьях: [Статья 1](https://habr.com/ru/companies/timeweb/articles/721488/) и [Статья 2](http://rcl-radio.ru/?p=132380).

В качестве источника тактовых импульсов необходимо взять кварцевый генератор (27МГц) расположенный на плате с ПЛИС.

Для отладки сигналов на выходе с ПЛИС можно использовать логический анализатор.

## Доп. задание

В качестве бонуса можете реализовать генератор псевдослучайного числа, оно должно выводится на индикатор каждую секунду.

В качестве основы можете использовать Регистр сдвига с линейной обратной связью или LFSR. Есть очень хорошая статья на [Вики](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D1%81%D0%B4%D0%B2%D0%B8%D0%B3%D0%B0_%D1%81_%D0%BB%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%BE%D0%B9_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B9_%D1%81%D0%B2%D1%8F%D0%B7%D1%8C%D1%8E).

## Советы по реализации

1) Ни в коем случае не используйте частоту кварцевого генератора, ваш CLK для сдвигового регистра должен быть достаточно низким, чтобы он успевал среагировать, но достаточно высоким, чтобы таймер не моргал (для нашего глаза). **Создайте делитель частоты**.
2) Ваше число будет 8 значным, но кодировать вы можете только 1 разряд, как это сделать? Для этого есть разные способы, но **ни в коем случае не используйте операцию деления**, то есть вам запрещено делить на 10 и целочисленно и с остатком от деления. Но как быть? Вам может помочь такое представление бинарного числа как BCD.
Чтобы преобразовать бинарное число в BCD есть следующий алгоритм:
    1) Вы создаете отдельный регистр из $4 \cdot ceil(N \cdot log_{10}(2))$
    2) Инициализируем BCD-регистр нулями.
    3) Выполняем цикл по количеству битов входного двоичного числа:
    - Если какая-либо BCD-тетрада (4-битная группа) ≥ 5, прибавляем 3 к этой тетраде.
    - Сдвигаем всё содержимое (и двоичное число, и BCD-регистр) влево на 1 бит, то есть ваш MSB бинарного числа становится LSB BCD числа.
    
    Разрешается использовать for для этого, так как он просто создает кучу сдвиговых регистров и сумматор с компараторами.

3) Прежде чем писать код на железке, вам необходимо все отладить в симуляции.

4) Перед выполнением Place & Route стоит переопределить Dual-Purpose pins, делается это по пути `Project -> Configuration -> Dual-Purpose Pin`, тут переопределяете все которые вызывают у вас ошибки.